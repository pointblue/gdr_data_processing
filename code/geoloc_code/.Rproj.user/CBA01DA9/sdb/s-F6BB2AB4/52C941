{
    "collab_server" : "",
    "contents" : "# Script for processing light-level geolocation data from 1718\n# Setting up to access files directly from AWS\n### Load packages\nrm(list = ls())\nlibrary(aws.s3)\nlibrary(stringr)\nlibrary(data.table)\nlibrary(dplyr)\nlibrary(tidyr)\nlibrary(fasttime)\nlibrary(lubridate)\nlibrary(devtools)\nlibrary(GeoLocTools)\nsetupGeolocation()\nlibrary(probGLS)\nlibrary(TwGeos)\nlibrary(ggplot2)\nlibrary(geosphere)\nlibrary(dplyr)\nlibrary(readr)\nlibrary(ggspatial)\nlibrary(maptools)\ndata(wrld_simpl)\nlibrary(abind)\nlibrary(rgdal)\nlibrary(sf)\nlibrary(googledrive)\n\n#######################\n## Analyze with SGAT ##\n#######################\n## Load twilight file\n#flist <- list.files(path=\"Z:/Informatics/S031/analyses/GDR/data/geoloc/1718/twl\", pattern=\"twl_long.csv\")\nload(\"C:/Users/adminlocal/Documents/GDR/data/geoloc/1718/Mask/v2.0/sstStack_2018.rda\")\n#sstStack <- drive_download(\"~geoloc/1718/Mask/v2.0/sstStack_2018.rda\")\n#load(\"C:/Users/adminlocal/Documents/GDR/data/geoloc/1718/Mask/v2.1/sstStack_2018.rda\")\ndepl_dat <- read.csv(\"C:/Users/adminlocal/Documents/GDR/data/geoloc/1718/meta/croz_royds_1718_retr_withdd.csv\")\nflist <- list.files(path=\"C:/Users/adminlocal/Documents/GDR/data/geoloc/1718/twl\", pattern=\"twl_long.csv\")\n#index=24:length(flist)\nindex <- 46:46 # flist[46] is bird 70449\n#i <- 46\nfor (i in index){\n  print(i)\n  ID <- substr(flist[i],1,nchar(flist[i])-13)\n  print(ID)\n  twl <- read.csv(paste0(\"C:/Users/adminlocal/Documents/GDR/data/geoloc/1718/twl/\", ID, \"_twl_long.csv\"))\n  twl$Twilight <- as.POSIXct(twl$Twilight, tz = \"GMT\")\n  twl <- subset(twl, !Deleted)  \n  twl <- twilightAdjust(twl, 60)\n  # Order on date\n  twl <- twl[order(twl$Twilight),]\n  print(head(twl))\n  # Subset for migration period with only 2 days at the colony on each side\n  dd <- read.csv(\"C:/Users/adminlocal/Documents/GDR/data/geoloc/1718/meta/croz_royds_1718_retr_withdd.csv\")\n  start <- as.POSIXct(dd$start[dd$filename==paste0(ID, \".txt\")], format=\"%m/%d/%Y\", tz = \"GMT\")\n  st.twl <- start - c(2*24*60*60)\n  end <- as.POSIXct(dd$end[dd$filename==paste0(ID, \".txt\")], format=\"%m/%d/%Y\", tz = \"GMT\")\n  retr <- as.POSIXct(dd$date_retrieved[dd$filename==paste0(ID, \".txt\")], format=\"%m/%d/%Y\", tz = \"GMT\")\n  if (end>=retr) {\n    end.twl <- end\n  } else if (difftime(retr, end, units=\"days\")==1) {\n    end.twl <- end + c(1*24*60*60)\n  } else {\n    end.twl = end + c(2*24*60*60)\n  }\n  twl <- subset(twl, twl$Twilight>=st.twl & twl$Twilight<=end.twl)\n  print(head(twl))\n  \n  ##################\n  ### Calibration ##\n  ##################\n  if (depl_dat$colony[depl_dat$filename==paste0(ID, \".txt\")]==\"croz\") {\n    lon.calib <- 169.237657\n    lat.calib <- -77.453600\n    calib <- c(96.2498399, 97.5389312, 4.3962314, 0.1710442) # Values come from the calibration of LUL353_P7, can be used for all tags FROM CROZ\n  } else {\n    lon.calib <- 166.168286\n    lat.calib <- -77.552929\n    calib <- c(95.93327559, 97.29943174, 2.71897057, 0.09853875) # Values come from the calibration of LUL538_CALIB_CR, can be used for all tags FROM ROYDS\n  }\n\n  ####################\n  ### Initial path ###\n  ####################\n  prj  <- sprintf(\"+proj=laea +lon_0=%s +lat_0=%s\", lon.calib, lat.calib)\n  bbox <- st_sfc(st_point(c(lon.calib, lat.calib))) %>% st_set_crs(prj) %>% st_buffer(2000000)\n  map  <- st_as_sf(wrld_simpl) \n  ln  <- st_sfc(st_linestring(cbind(seq(-180, 180, by = 1), lat.calib))) %>% \n    st_set_crs(proj4string(wrld_simpl)) \n  \n  opar <- par(mar = c(0,0,0,0))\n  plot(bbox)\n  plot(map$geometry, col = \"grey90\", border = \"grey80\", add = T)\n  plot(ln, add = T, col = \"grey20\")\n  \n  x0_0 <- with(twl[!twl$Inserted,], thresholdPath(Twilight, Rise, zenith = calib[1], tol=0.15)$x) \n  x0_0[,1] <- ifelse(x0_0[,1]<0, 180 + (180 + x0_0[,1]), x0_0[,1])\n  x0 <- matrix(NA, ncol = 2, nrow = nrow(twl))\n  x0[c(1, nrow(x0)),] <- matrix(c(lon.calib, lat.calib), byrow = T, ncol = 2, nrow = 2) \n  x0[!twl$Inserted]   <- x0_0\n  x0 <- apply(x0, 2, function(x) zoo::na.approx(x))    \n  \n  points(project(x0, prj), col = adjustcolor(\"cornflowerblue\", alpha.f = 0.5), type = \"l\")\n  points(project(x0, prj), col = viridis::magma(nrow(x0)), pch = 16)\n  points(project(matrix(c(lon.calib, lat.calib), ncol = 2), prj), pch = 16, cex = 2.5, col = \"firebrick\")\n  par(opar)\n \n  ##############################\n  ### Get temperature data #####\n  ##############################\n  td  <- read.csv(paste0(\"C:/Users/adminlocal/Documents/GDR/data/geoloc/1718/td/\", ID, \"_td.csv\"))\n  td$Date <- as.POSIXct(td$dtime, tz = \"GMT\")\n  td <- subset(td, td$Date>=st.twl & td$Date<=end.twl)\n  td$ind <- td$wetdry==1 & c(NA,head(td$wetdry,-1))==1 & c(NA,NA,head(td$wetdry,-2))==1 #& c(NA,NA,NA,head(td$wetdry,-3))==1\n  td <- td[!is.na(td$Date),]\n  #td <- td[!is.na(td$ind),]\n  print(head(td))\n  \n  ## assign temp to twl \n  twl_temp_ind <- t(sapply(as.numeric(twl$Twilight), function(x) {\n    out <- which(abs(as.numeric(td$Date)-x)<12*60*60)\n    if(length(out)>0) range(out) else c(NA, NA)\n  }))\n  \n  #xx <- td[twl_temp_ind[402,1]:twl_temp_ind[402,2],]\n  #plot(xx$Date, xx$temp, pch = 16, col = ifelse(xx$ind, \"blue\", adjustcolor(\"grey90\", 0.5)))\n  #par(new = TRUE)\n  #plot(xx$Date, xx$depth, type = \"l\", col = \"darkblue\", xaxt = \"n\", yaxt = \"n\", xlab = \"\", ylab = \"\", ylim = c(0, 50))\n  #axis(4)\n  \n  twl_temp <- do.call(\"rbind\", apply(twl_temp_ind, 1, function(x) {\n    if(any(is.na(x))) NA else {\n      tmp <- td[x[1]:x[2],]\n      if(length(tmp$temp[tmp$ind])>=5) quantile(tmp$temp[tmp$ind], probs = c(0.25, 0.75), na.rm = T) else NA\n    }\n  }))\n  \n  print(head(twl_temp))\n\n  plot(twl$Twilight, twl_temp[,1], type = \"o\")\n  abline(h=-1.8, col=\"red\")\n  \n  ############# SST data mask ###############################################################################################\n  ## sst layer downloaded from: https://www.esrl.noaa.gov/psd/data/gridded/data.noaa.oisst.v2.highres.html ###\n  ##########################################################################################################################\n  \n  xlim = c(145, 245)\n  ylim = c(-80, -50)\n  \n  sst <- crop(sstStack, as(extent(c(xlim, ylim)), \"SpatialPolygons\"))\n  sst_dates <- as.POSIXct(substr(names(sst), 6, nchar(names(sst))), format = \"%Y.%m.%d\", tz = \"GMT\")\n  \n  dateInd <- sapply(as.numeric(twl$Twilight), function(x) which.min(abs(x-as.numeric(sst_dates))))\n  \n  SST <- sst[[dateInd]]\n  \n  ### Twiligth specific mask (raster stack) # \n  sstArray <- abind(lapply(1:length(dateInd), function(x) {\n    SST <- sst[[dateInd[x]]]\n    if(!is.na(twl_temp[x,1])) {\n      SST[] <- dnorm(SST[], ifelse(twl_temp[x,1] < -1.8, -1.8, twl_temp[x,1]), 0.5)\n      SST[] <- (SST[] - min(SST[], na.rm = T))/(max(SST[], na.rm = T) - min(SST[], na.rm = T))\n    } else  {\n      SST[] <- ifelse(!is.na(SST[]), 1, NA)\n    }\n    as.matrix(SST)[nrow(SST):1,]\n  }), along = 3)\n  \n  xbin = seq(xlim[1],xlim[2],length=dim(sstArray)[2])\n  ybin = seq(ylim[1],ylim[2],length=dim(sstArray)[1])\n  sstMask <- function(p) {\n    f <- apply(cbind(1:nrow(p)), 1, function(x) sstArray[cbind(.bincode(p[x,2], ybin), .bincode(p[x,1], xbin), x)])\n    ifelse(is.na(f), -1000, f*2)\n  }\n  \n  ### test map\n  #ind <- 500\n  #t <- SST[[ind]]\n  #t[] <- apply(coordinates(t), 1, function(x) sstArray[cbind(.bincode(x[2], ybin), .bincode(x[1], xbin), ind)])\n  #print(plot(t))\n  \n  #beta  <- c(0.7, 0.25) # MOVEMENT MODEL\n  beta  <- c(0.2, 0.25) # Try slower speeds\n  plot(1:40, dgamma(1:40, beta[1], beta[2]))\n  \n  # Define known location dates\n  fixedx <- rep(FALSE, nrow(twl)) # USE DATA FROM LAST SEEN/ FIRST SEEN AT THE COLONY\n  fixedx[which(twl$Twilight<=start|twl$Twilight>=(end.twl - c(1*24*60*60)))] <- TRUE # start and end dates from deploy file with dry dates\n  x0[fixedx,1] <- lon.calib \n  x0[fixedx,2] <- lat.calib\n  \n  z0 <- trackMidpts(x0)\n  \n  model <- thresholdModel(twl$Twilight,\n                          twl$Rise,\n                          twilight.model = \"ModifiedGamma\",\n                          alpha = calib[3:4],\n                          beta =  beta,\n                          x0 = x0, \n                          z0 = z0, \n                          zenith = calib[2],\n                          logp.x = sstMask,\n                          logp.z = sstMask, # use mask for z positions too\n                          missing = ifelse(twl$Inserted, 2, 0),\n                          fixedx = fixedx)\n  \n  # define the error shape\n  x.proposal <- mvnorm(S = diag(c(0.005, 0.005)), n = nrow(x0))\n  z.proposal <- mvnorm(S = diag(c(0.005, 0.005)), n = nrow(z0))\n  \n  # Fit the model\n  fit <- estelleMetropolis(model, x.proposal, z.proposal, iters = 2000, thin = 20)\n  \n  # Remove proposals outside of the sst mask/polygon\n  x0_new  <- chainLast(fit$x)\n  indX0 <- st_as_sf(data.frame(long = x0_new[[1]][,1], lat = x0_new[[1]][,2]), coords = c(\"long\", \"lat\")) %>%\n    st_intersects(st_as_sfc(as(extent(sst), \"SpatialPolygons\")), sparse=FALSE)\n  x0_new[[1]][as.numeric(indX0)!=1,1] <- NA\n  x0_new[[1]][as.numeric(indX0)!=1,2] <- NA\n  x0_new[[1]] <- apply(x0_new[[1]], 2, function(x) zoo::na.approx(x))\n  z0_new <- chainLast(fit$z)\n  z0_new[[1]] <- trackMidpts(x0_new[[1]]) \n  \n  # Tune proposals\n  for (k in 1:3) {\n    x.proposal <- mvnorm(chainCov(fit$x), s = 0.3)\n    z.proposal <- mvnorm(chainCov(fit$z), s = 0.3)\n    fit <- estelleMetropolis(model, x.proposal, z.proposal, x0 = x0_new,\n                             z0 = z0_new, iters = 300, thin = 20)\n  }\n  \n  x0_new  <- chainLast(fit$x)\n  indX0 <- st_as_sf(data.frame(long = x0_new[[1]][,1], lat = x0_new[[1]][,2]), coords = c(\"long\", \"lat\")) %>%\n    st_intersects(st_as_sfc(as(extent(sst), \"SpatialPolygons\")), sparse=FALSE)\n  x0_new[[1]][as.numeric(indX0)!=1,1] <- NA\n  x0_new[[1]][as.numeric(indX0)!=1,2] <- NA\n  x0_new[[1]] <- apply(x0_new[[1]], 2, function(x) zoo::na.approx(x))\n  z0_new <- chainLast(fit$z)\n  z0_new[[1]] <- trackMidpts(x0_new[[1]]) \n  \n  ## Check if chains mix # Need to explore the space quickly (up and down, and tight)\n  opar <- par(mfrow = c(2, 1), mar = c(3, 5, 2, 1) + 0.1)\n  matplot(t(fit$x[[1]][, 1, ]), type = \"l\", lty = 1, col = \"dodgerblue\", ylab = \"Lon\", ylim=c(140,250))\n  matplot(t(fit$x[[1]][, 2, ]), type = \"l\", lty = 1, col = \"firebrick\", ylab = \"Lat\", ylim=c(-90,-40))\n  par(opar)\n  \n  x.proposal <- mvnorm(chainCov(fit$x), s = 0.3)\n  z.proposal <- mvnorm(chainCov(fit$z), s = 0.3)\n  \n  fit <- estelleMetropolis(model, x.proposal, z.proposal, x0 = x0_new,\n                           z0 = z0_new, iters = 2000, thin = 20, chain = 1)\n  \n  save(fit, file = paste0(\"C:/Users/adminlocal/Documents/GDR/data/geoloc/1718/fit/\", ID, \"_fit.RData\"))\n\n  sm  <- locationSummary(fit$x, time=fit$model$time)\n  write.csv(sm, file = paste0(\"C:/Users/adminlocal/Documents/GDR/data/geoloc/1718/fit/\", ID, \"_LocSummary.csv\"), row.names=FALSE)\n  \n  r   <- raster(nrows = 2 * diff(ylim), ncols = 2 * diff(xlim), xmn = xlim[1]-5,\n                xmx = xlim[2]+5, ymn = ylim[1]-5, ymx = ylim[2]+5, crs = proj4string(wrld_simpl)) # DENSITY DISTRIBUTION OF TIME SPENT\n  \n  s  <- slices(type = \"intermediate\", mcmc = fit, grid = r)\n  sk <- SGAT:::slice(s, sliceIndices(s))\n\n  png(paste0(\"C:/Users/adminlocal/Documents/GDR/data/geoloc/1718/fig/\",ID,\"_map-mov02_SST2.0_oldcode\",\".png\"),height = 8, width = 8, units = \"in\", res = 150, pointsize = 12,  bg = \"white\",restoreConsole = TRUE)\n  plot(sk, legend = F, xlim = xlim, ylim = ylim) # INTERPRETATION\n  plot(wrld_simpl, add = T, bg = adjustcolor(\"black\",alpha=0.1))\n  plot(elide(wrld_simpl, shift = c(360,0)), add = T, bg = adjustcolor(\"black\",alpha=0.1)) # COLORED BACKGROUND = DENSITY DISTRIBUTION OF TIME SPENT\n  lines(sm[,\"Lon.50%\"], sm[,\"Lat.50%\"], col = \"black\", type = \"l\", pch = 16, cex = 0.5) # MEDIAN TRACK\n  lines(sm[,\"Lon.50%\"], sm[,\"Lat.50%\"], col = heat.colors(nrow(sm)), type = \"o\", pch = 16, cex = 0.5) # starts with red, ends with white\n  points(lon.calib, lat.calib, pch = 21, bg = \"white\")\n  dev.off()\n  \n  # Plot latitude to look at deviations around equinoxes\n  png(paste0(\"C:/Users/adminlocal/Documents/GDR/data/geoloc/1718/fig/\",ID,\"_lat\",\".png\"),height = 8, width = 8, units = \"in\", res = 150, pointsize = 12,  bg = \"white\",restoreConsole = TRUE)\n  par(mar=c(5.1, 4.1, 4.1, 2.1))\n  plot(sm$Time, sm$\"Lat.50%\", type=\"n\")\n  polygon(x=c(sm$Time,rev(sm$Time)), y=c(sm$`Lat.2.5%`,rev(sm$`Lat.97.5%`)), border=\"gray\", col=\"gray\")\n  lines(sm$Time,sm$\"Lat.50%\", lwd = 2)\n  abline(v=as.POSIXct(\"2018-03-15\", tz=\"GMT\"), lty=2)\n  abline(v=as.POSIXct(\"2018-03-25\", tz=\"GMT\"), lty=2)\n  abline(v=as.POSIXct(\"2018-09-18\", tz=\"GMT\"), lty=2)\n  abline(v=as.POSIXct(\"2018-09-28\", tz=\"GMT\"), lty=2)\n  points(sm$Time, x0[,2], type=\"l\", lwd=2, col=\"orange\") # add initial path\n  dev.off()\n  \n  # Plot daily average measured temperature\n  png(paste0(\"C:/Users/adminlocal/Documents/GDR/data/geoloc/1718/fig/\",ID,\"_temp\",\".png\"),height = 8, width = 8, units = \"in\", res = 150, pointsize = 12,  bg = \"white\",restoreConsole = TRUE)\n  tp <- data.frame(Dtime=twl$Twilight, Temp=twl_temp[,1])\n  tp$Date <- as.Date(tp$Dtime)\n  tab <- tapply(tp$Temp, tp$Date, mean, na.rm=TRUE)\n  par(mar = c(5.1, 4.1, 4.1, 2.1))\n  plot(unique(tp$Date), tab, type=\"l\", lwd=2, col=\"blue\", ylab=\"Average recorded temp (?C)\", xlab=\"\")\n  abline(h=-1.8, col=\"red\")\n  dev.off()\n  \n  # Estimate the deviation between the measured vs. the modelled sunrise and sunset times\n  tm_twl  <- twilight(sm$Time, sm$\"Lon.50%\", sm$\"Lat.50%\", rise = model$rise, zenith = calib[1], iters = 5) \n  diff_tab <- difftime(twl$Twilight, tm_twl, units = \"mins\")\n  plot(twl$Twilight[twl$Rise], abs(diff_tab[twl$Rise]), pch = 16, col = \"firebrick\", ylim = c(0, 60), type = \"l\")\n  lines(twl$Twilight[!twl$Rise], abs(diff_tab[!twl$Rise]), pch = 16, col = \"cornflowerblue\")\n}\n  \n ## END ## \n  \n\n### TO USE IN CASE OF PROBLEMS\nrange(which(raw$Date>=as.POSIXct(\"2019-04-01\")&raw$Date<=as.POSIXct(\"2019-04-05\")))\nplot(raw$Date[13157605:13503194], raw$Light[13157605:13503194], type = \"o\", pch = 16, cex = 0.5)\nabline(h = threshold)\nx <- raw$Light[13157605:13503194]\ny <- x[which(x>1&x<2)] # Change threshold to 1.2\n#twl  <- preprocessLight(raw, threshold, offset = 1, lmax = 11, gr.Device = \"x11\")\n\n# Plot twilights\nraw <- data.frame(Date = seq(min(twl$Twilight), max(twl$Twilight), by = 60), Light = 0)\nlightImage(raw, offset = 0, zlim = c(0, 25), dt = 120)\ntsimagePoints(twl$Twilight, offset = 0, pch = 16, cex = 1,\n              col = ifelse(twl$Rise, \"dodgerblue\", \"firebrick\"))\n\n# Short-circuiting twl_temp to look at temp records effects\nfor(i in 1:nrow(twl)) {\n  \n  if(!is.na(twl_temp[i,1])) {\n    SST[[i]][] <- ifelse(SST[[i]][]<2, 1, 0)\n  } else SST[[i]][] <- ifelse(!is.na(SST[[i]][]), 1, NA)\n  \n  if(i == 1) sstArray <- as.matrix(SST[[i]])[nrow(SST[[i]]):1,] else sstArray <- abind(sstArray, as.matrix(SST[[i]])[nrow(SST[[i]]):1,], along = 3)\n}\n\n## Detect missing or multiple twilights in twl files\ntwl <- read.csv(\"C:/Users/adminlocal/Documents/GDR/data/geoloc/1718/twl/000032204_0168c17_twl_long.csv\")\ntwl$Twilight <- as.POSIXct(twl$Twilight, tz = \"GMT\")\ntwl <- subset(twl, !Deleted)  \ntwl <- twilightAdjust(twl, 60)\ntwl <- twl[order(twl$Twilight),]\ntwl <- twl[!twl$Inserted,]\n# Look for missing days\nrg <- as.Date(range(twl$Twilight))\nseq <- as.Date(rep(rg[1]:rg[2], each=2))\nd_twl <- as.Date(twl$Twilight)\nmissing <- seq %in% d_twl\nwhich(missing==\"FALSE\")\nseq[110]\ntwl[100:120,]\n# Look for days that have less or more than 2 twilights\ntest <- twl %>%\n  group_by(as.Date(twl$Twilight)) %>%\n  summarize(n())\ntest <- as.data.frame(test)\nflag <- which(test[,2]!=2)\nflag\ntest[384,]\ntwl[560:580,]\n# Remove additional twilights and save\ntwl <- read.csv(\"C:/Users/adminlocal/Documents/GDR/data/geoloc/1718/twl/000032204_0168c17_twl_long.csv\")\ntwl$Twilight <- as.POSIXct(twl$Twilight, tz = \"GMT\")\ntwl <- twl[order(twl$Twilight),]\ntwl[650:700,]\ntwl <- twl[-c(198,671), ]\ntwl[567,]\ntwl <- twl[-c(103), ]\ntwl <- data.frame(Twilight=twl$Twilight, Rise=twl$Rise, Deleted=twl$Deleted, Edited=twl$Edited, Twilight0=twl$Twilight0, Inserted=twl$Inserted)\nwrite.csv(twl, \"C:/Users/adminlocal/Documents/GDR/data/geoloc/1718/twl/000032204_0168c17_twl_long.csv\", row.names=FALSE)\n",
    "created" : 1600109647404.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "904710266",
    "id" : "52C941",
    "lastKnownWriteTime" : 1600109377,
    "last_content_update" : 1600109377,
    "path" : "~/GDR/geoloc/code/GDR_analysis_SGAT_1718_tracks_batch.R",
    "project_path" : "code/GDR_analysis_SGAT_1718_tracks_batch.R",
    "properties" : {
    },
    "relative_order" : 1,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}