---
title: "SGTA: From MCMC values to probability maps"
author: "Simeon Lisovski"
date: "4/19/2021"
output: html_document
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
geolocPath <- "~/Google Drive/Shared/geoloc/results_1617/fit/"
``` 

## SGAT output

The final output of the bayesian SGAT geolight analysis is a so called `fit` object generated by the function `estelleMetropolis`.

This object contains:

* `model` - the model structure (including twilight times etc.)
* `x` - a list of n x p x r arrays of twilight locations from the q chains
* `z` - a list of (n-1) x p x r arrays of intermediate locations from the q chains

## The `slice` functions

These functions `slice` and `slices` divide a trip (track estimate) into time slices, and generate location density estimates for each time slice.

The slices function defines the slices into which the trip is divided, and whether density estimates are generated for the primary (x) or intermediate (z) locations. If breaks is `NULL`, each location forms a separate time slice, otherwise breaks divides the trip into time slices in the same style as `cut.POSIXt`. A default set of samples and a raster defining the spatial grid may also be specified.

The slice function generates a density estimate for a time slice, `sliceInterval` returns the corresponding time interval, and `sliceIndices` returns the indices that will yield non null raster.


## Example

Loading a fit object:

```{r, warning=FALSE, message=FALSE}
library(SGAT)
load(paste0(geolocPath, "51069_fit.RData"))
```

Next, we create an empty raster with the desired spatial extent and resolution.

```{r, warning=FALSE, message=FALSE}
library(raster)
xlim = c(140, 250) ## not that this example has locations that cross the dateline, thus we go beyond 180 degrees East.
ylim = c(-87, -50)

r   <- raster(xmn = xlim[1], xmx = xlim[2], ymn = ylim[1], ymx = ylim[2], res = 0.15, crs = "+proj=longlat")
```

Now, we can use the `slice` function to generate the location density estimates (here we use intermediate z locations).

```{r}
s  <- slices(type = "intermediate", mcmc = fit, grid = r)
```

Since we did not specify brakes, we have generated one slice for each twilight time:

```{r}
length(sliceIndices(s)) == length(fit$model$time)-1 ## -1 because we use intermediate locations
```

We can now merge the slices into a slice (raster) using all time slices:

```{r}
sk <- slice(s, sliceIndices(s))
```

And plot the raster (and a map from the `rnaturalearthdata` package).

```{r, warning=FALSE, message=FALSE, fig.width=10, fig.height=4}
library(sf)

map <- st_as_sf(rnaturalearthdata::coastline50) %>%
  st_difference(st_as_sf(as(extent(c(-10,10,-90,90)), "SpatialPolygons")) %>% st_set_crs(4326)) %>%
  st_shift_longitude() %>%
  st_intersection(st_as_sf(as(extent(sk), "SpatialPolygons")) %>% st_set_crs(4326))

opar <- par(bty = "n")
plot(as(extent(sk), "SpatialPolygons"))
plot(sk, col = rev(viridis::magma(100)), xaxt = "n", yaxt = "n", add = T, legend = FALSE)
plot(map$geometry, add = T)
par(opar)
```


### Subset the `slice`

It is possible to use certain periods only or exclude certain slices. Let's generate a map for September only:

```{r, warning=FALSE, message=FALSE, fig.width=10, fig.height=4}
sk <- slice(s, which(format(fit$model$time, "%b")=="Sep"))

opar <- par(bty = "n")
plot(as(extent(sk), "SpatialPolygons"))
plot(sk, col = rev(viridis::magma(100)), xaxt = "n", yaxt = "n", add = T, legend = FALSE)
plot(map$geometry, add = T)
mtext("September slice", 3)
par(opar)
```


### Get quantiles of location density estimates

```{r}
sk <- slice(s, sliceIndices(s))

## divide by the value range to rescale to 0,1 
scl <- function(x) {
(x - min(x,na.rm = TRUE)) / diff(range(x, na.rm = TRUE))
}
 
subx <- trim(sk, value = 0) ## use trim to zoom in (not much point in the 100% contour, but you can see it) 
subx <- setValues(subx, scl(values(subx)))


opar <- par(bty = "n")
plot(as(extent(subx), "SpatialPolygons"))
plot(subx, col = rev(viridis::magma(100)), xaxt = "n", yaxt = "n", add = T, legend = FALSE)
plot(map$geometry, add = T)
contour(subx, levels = seq(20, 80, length = 2)/100, add = TRUE, col = "white", lwd = 2) ## 20 and 80th percentile
par(opar)
```




